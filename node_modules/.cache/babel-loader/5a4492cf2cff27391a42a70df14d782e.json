{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.default = void 0;\n\nvar _normalizeTrailingSlash = require(\"../../../client/normalize-trailing-slash\");\n\nvar _routeLoader = require(\"../../../client/route-loader\");\n\nvar _isError = _interopRequireDefault(require(\"../../../lib/is-error\"));\n\nvar _denormalizePagePath = require(\"../../../server/denormalize-page-path\");\n\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\n\nvar _mitt = _interopRequireDefault(require(\"../mitt\"));\n\nvar _utils = require(\"../utils\");\n\nvar _isDynamic = require(\"./utils/is-dynamic\");\n\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\n\nvar _querystring = require(\"./utils/querystring\");\n\nvar _resolveRewrites = _interopRequireDefault(require(\"./utils/resolve-rewrites\"));\n\nvar _routeMatcher = require(\"./utils/route-matcher\");\n\nvar _routeRegex = require(\"./utils/route-regex\");\n\nvar _getMiddlewareRegex = require(\"./utils/get-middleware-regex\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nlet detectDomainLocale;\n\nif (process.env.__NEXT_I18N_SUPPORT) {\n  detectDomainLocale = require('../i18n/detect-domain-locale').detectDomainLocale;\n}\n\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\n\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true\n  });\n}\n\nfunction addPathPrefix(path, prefix) {\n  if (!path.startsWith('/') || !prefix) {\n    return path;\n  }\n\n  const pathname = pathNoQueryHash(path);\n  return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(`${prefix}${pathname}`) + path.substr(pathname.length);\n}\n\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    locale = locale || (0, _normalizeLocalePath).normalizeLocalePath(path, locales).detectedLocale;\n    const detectedDomain = detectDomainLocale(domainLocales, undefined, locale);\n\n    if (detectedDomain) {\n      return `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${basePath || ''}${locale === detectedDomain.defaultLocale ? '' : `/${locale}`}${path}`;\n    }\n\n    return false;\n  } else {\n    return false;\n  }\n}\n\nfunction addLocale(path, locale, defaultLocale) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    const pathname = pathNoQueryHash(path);\n    const pathLower = pathname.toLowerCase();\n    const localeLower = locale && locale.toLowerCase();\n    return locale && locale !== defaultLocale && !pathLower.startsWith('/' + localeLower + '/') && pathLower !== '/' + localeLower ? addPathPrefix(path, '/' + locale) : path;\n  }\n\n  return path;\n}\n\nfunction delLocale(path, locale) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    const pathname = pathNoQueryHash(path);\n    const pathLower = pathname.toLowerCase();\n    const localeLower = locale && locale.toLowerCase();\n    return locale && (pathLower.startsWith('/' + localeLower + '/') || pathLower === '/' + localeLower) ? (pathname.length === locale.length + 1 ? '/' : '') + path.substr(locale.length + 1) : path;\n  }\n\n  return path;\n}\n\nfunction pathNoQueryHash(path) {\n  const queryIndex = path.indexOf('?');\n  const hashIndex = path.indexOf('#');\n\n  if (queryIndex > -1 || hashIndex > -1) {\n    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n  }\n\n  return path;\n}\n\nfunction hasBasePath(path) {\n  path = pathNoQueryHash(path);\n  return path === basePath || path.startsWith(basePath + '/');\n}\n\nfunction addBasePath(path) {\n  // we only add the basepath on relative urls\n  return addPathPrefix(path, basePath);\n}\n\nfunction delBasePath(path) {\n  path = path.slice(basePath.length);\n  if (!path.startsWith('/')) path = `/${path}`;\n  return path;\n}\n\nfunction isLocalURL(url) {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n\n  try {\n    // absolute urls can be local if they are on the same origin\n    const locationOrigin = (0, _utils).getLocationOrigin();\n    const resolved = new URL(url, locationOrigin);\n    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction interpolateAs(route, asPathname, query) {\n  let interpolatedRoute = '';\n  const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n  const dynamicGroups = dynamicRegex.groups;\n  const dynamicMatches = // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  const params = Object.keys(dynamicGroups);\n\n  if (!params.every(param => {\n    let value = dynamicMatches[param] || '';\n    const {\n      repeat,\n      optional\n    } = dynamicGroups[param]; // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n\n    let replaced = `[${repeat ? '...' : ''}${param}]`;\n\n    if (optional) {\n      replaced = `${!value ? '/' : ''}[${replaced}]`;\n    }\n\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present\n    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just\n    // path delimiter escaped since they are being inserted\n    // into the URL and we expect URL encoded segments\n    // when parsing dynamic route params\n    segment => encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');\n  })) {\n    interpolatedRoute = '' // did not satisfy all requirements\n    ; // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n\n  return {\n    params,\n    result: interpolatedRoute\n  };\n}\n\nfunction omitParmsFromQuery(query, params) {\n  const filteredQuery = {};\n  Object.keys(query).forEach(key => {\n    if (!params.includes(key)) {\n      filteredQuery[key] = query[key];\n    }\n  });\n  return filteredQuery;\n}\n\nfunction resolveHref(router, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  let base;\n  let urlAsString = typeof href === 'string' ? href : (0, _utils).formatWithValidation(href); // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n\n  const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n  const urlAsStringNoProto = urlProtoMatch ? urlAsString.substr(urlProtoMatch[0].length) : urlAsString;\n  const urlParts = urlAsStringNoProto.split('?');\n\n  if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n    console.error(`Invalid href passed to next/router: ${urlAsString}, repeated forward-slashes (//) or backslashes \\\\ are not valid in the href`);\n    const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n  } // Return because it cannot be routed by the Next.js router\n\n\n  if (!isLocalURL(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n\n  try {\n    base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL('/', 'http://n');\n  }\n\n  try {\n    const finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n    let interpolatedAs = '';\n\n    if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n      const {\n        result,\n        params\n      } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n\n      if (result) {\n        interpolatedAs = (0, _utils).formatWithValidation({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: omitParmsFromQuery(query, params)\n        });\n      }\n    } // if the origin didn't change, it means we received a relative href\n\n\n    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_1) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\n\nfunction stripOrigin(url) {\n  const origin = (0, _utils).getLocationOrigin();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  let [resolvedHref, resolvedAs] = resolveHref(router, url, true);\n  const origin = (0, _utils).getLocationOrigin();\n  const hrefHadOrigin = resolvedHref.startsWith(origin);\n  const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  const preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n  const preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  const cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(page => {\n      if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\n\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function () {\n  try {\n    let v = '__next'; // eslint-disable-next-line no-sequences\n\n    return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n  } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\n\nfunction fetchRetry(url, attempts, opts) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin'\n  }).then(res => {\n    if (!res.ok) {\n      if (attempts > 1 && res.status >= 500) {\n        return fetchRetry(url, attempts - 1, opts);\n      }\n\n      if (res.status === 404) {\n        return res.json().then(data => {\n          if (data.notFound) {\n            return {\n              notFound: SSG_DATA_NOT_FOUND\n            };\n          }\n\n          throw new Error(`Failed to load static props`);\n        });\n      }\n\n      throw new Error(`Failed to load static props`);\n    }\n\n    return opts.text ? res.text() : res.json();\n  });\n}\n\nfunction fetchNextData(dataHref, isServerRender, text, inflightCache, persistCache) {\n  const {\n    href: cacheKey\n  } = new URL(dataHref, window.location.href);\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1, {\n    text\n  }).catch(err => {\n    // We should only trigger a server-side transition if this was caused\n    // on a client-side transition. Otherwise, we'd get into an infinite\n    // loop.\n    if (!isServerRender) {\n      (0, _routeLoader).markAssetError(err);\n    }\n\n    throw err;\n  }).then(data => {\n    if (!persistCache || process.env.NODE_ENV !== 'production') {\n      delete inflightCache[cacheKey];\n    }\n\n    return data;\n  }).catch(err => {\n    delete inflightCache[cacheKey];\n    throw err;\n  });\n}\n\nclass Router {\n  constructor(pathname, query, as, _ref) {\n    let {\n      initialProps,\n      pageLoader,\n      App,\n      wrapApp,\n      Component,\n      err,\n      subscription,\n      isFallback,\n      locale,\n      locales,\n      defaultLocale,\n      domainLocales,\n      isPreview\n    } = _ref;\n    // Static Data Cache\n    this.sdc = {}; // In-flight Server Data Requests, for deduping\n\n    this.sdr = {}; // In-flight middleware preflight requests\n\n    this.sde = {};\n    this._idx = 0;\n\n    this.onPopState = e => {\n      const state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        const {\n          pathname,\n          query\n        } = this;\n        this.changeState('replaceState', (0, _utils).formatWithValidation({\n          pathname: addBasePath(pathname),\n          query\n        }), (0, _utils).getURL());\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      }\n\n      let forcedScroll;\n      const {\n        url,\n        as,\n        options,\n        idx\n      } = state;\n\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          if (this._idx !== idx) {\n            // Snapshot current scroll position:\n            try {\n              sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n                x: self.pageXOffset,\n                y: self.pageYOffset\n              }));\n            } catch {} // Restore old scroll position:\n\n\n            try {\n              const v = sessionStorage.getItem('__next_scroll_' + idx);\n              forcedScroll = JSON.parse(v);\n            } catch {\n              forcedScroll = {\n                x: 0,\n                y: 0\n              };\n            }\n          }\n        }\n      }\n\n      this._idx = idx;\n      const {\n        pathname\n      } = (0, _parseRelativeUrl).parseRelativeUrl(url); // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n      if (this.isSsr && as === this.asPath && pathname === this.pathname) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (this._bps && !this._bps(state)) {\n        return;\n      }\n\n      this.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && this._shallow,\n        locale: options.locale || this.defaultLocale\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    this.route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname !== '/_error') {\n      var ref;\n      this.components[this.route] = {\n        Component,\n        initial: true,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP,\n        __N_RSC: !!((ref = Component) === null || ref === void 0 ? void 0 : ref.__next_rsc__)\n      };\n    }\n\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: []\n    }; // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader;\n    this.pathname = pathname;\n    this.query = query; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.asPath = autoExportDynamic ? pathname : as;\n    this.basePath = basePath;\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isFallback = isFallback;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n    this.isPreview = !!isPreview;\n    this.isLocaleDomain = false;\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locale = locale;\n      this.locales = locales;\n      this.defaultLocale = defaultLocale;\n      this.domainLocales = domainLocales;\n      this.isLocaleDomain = !!detectDomainLocale(domainLocales, self.location.hostname);\n    }\n\n    if (typeof window !== 'undefined') {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (as.substr(0, 2) !== '//') {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        const options = {\n          locale\n        };\n        options._shouldResolveHref = as !== pathname;\n        this.changeState('replaceState', (0, _utils).formatWithValidation({\n          pathname: addBasePath(pathname),\n          query\n        }), (0, _utils).getURL(), options);\n      }\n\n      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          window.history.scrollRestoration = 'manual';\n        }\n      }\n    }\n  }\n\n  reload() {\n    window.location.reload();\n  }\n  /**\n  * Go back in history\n  */\n\n\n  back() {\n    window.history.back();\n  }\n  /**\n  * Performs a `pushState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n\n\n  push(url, as) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (process.env.__NEXT_SCROLL_RESTORATION) {\n      // TODO: remove in the future when we update history before route change\n      // is complete, as the popstate event should handle this capture.\n      if (manualScrollRestoration) {\n        try {\n          // Snapshot scroll position right before navigating to a new page:\n          sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n            x: self.pageXOffset,\n            y: self.pageYOffset\n          }));\n        } catch {}\n      }\n    }\n\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('pushState', url, as, options);\n  }\n  /**\n  * Performs a `replaceState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n\n\n  replace(url, as) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('replaceState', url, as, options);\n  }\n\n  async change(method, url, as, options, forcedScroll) {\n    if (!isLocalURL(url)) {\n      window.location.href = url;\n      return false;\n    }\n\n    const shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as); // for static pages with query params in the URL we delay\n    // marking the router ready until after the query is updated\n\n    if (options._h) {\n      this.isReady = true;\n    }\n\n    const prevLocale = this.locale;\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;\n\n      if (typeof options.locale === 'undefined') {\n        options.locale = this.locale;\n      }\n\n      const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n      const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n\n      if (localePathResult.detectedLocale) {\n        this.locale = localePathResult.detectedLocale;\n        parsedAs.pathname = addBasePath(parsedAs.pathname);\n        as = (0, _utils).formatWithValidation(parsedAs);\n        url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);\n      }\n\n      let didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        var ref; // if the locale isn't configured hard navigate to show 404 page\n\n        if (!((ref = this.locales) === null || ref === void 0 ? void 0 : ref.includes(this.locale))) {\n          parsedAs.pathname = addLocale(parsedAs.pathname, this.locale);\n          window.location.href = (0, _utils).formatWithValidation(parsedAs); // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n\n          didNavigate = true;\n        }\n      }\n\n      const detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale); // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        // if we are navigating to a domain locale ensure we redirect to the\n        // correct domain\n        if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n          const asNoBasePath = delBasePath(as);\n          window.location.href = `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${addBasePath(`${this.locale === detectedDomain.defaultLocale ? '' : `/${this.locale}`}${asNoBasePath === '/' ? '' : asNoBasePath}` || '/')}`; // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n\n          didNavigate = true;\n        }\n      }\n\n      if (didNavigate) {\n        return new Promise(() => {});\n      }\n    }\n\n    if (!options._h) {\n      this.isSsr = false;\n    } // marking route changes as a navigation start entry\n\n\n    if (_utils.ST) {\n      performance.mark('routeChange');\n    }\n\n    const {\n      shallow = false\n    } = options;\n    const routeProps = {\n      shallow\n    };\n\n    if (this._inFlightRoute) {\n      this.abortComponentLoad(this._inFlightRoute, routeProps);\n    }\n\n    as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n    const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);\n    this._inFlightRoute = as;\n    let localeChange = prevLocale !== this.locale; // If the url change is only related to a hash change\n    // We should not proceed. We should only change the state.\n    // WARNING: `_h` is an internal option for handing Next.js client-side\n    // hydration. Your app should _never_ use this property. It may change at\n    // any time without notice.\n\n    if (!options._h && this.onlyAHashChange(cleanedAs) && !localeChange) {\n      this.asPath = cleanedAs;\n      Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n      this.changeState(method, url, as, options);\n      this.scrollToHash(cleanedAs);\n      this.notify(this.components[this.route], null);\n      Router.events.emit('hashChangeComplete', as, routeProps);\n      return true;\n    }\n\n    let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n    let {\n      pathname,\n      query\n    } = parsed; // The build manifest needs to be loaded before auto-static dynamic pages\n    // get their query parameters to allow ensuring they can be parsed properly\n    // when rewritten to\n\n    let pages, rewrites;\n\n    try {\n      [pages, {\n        __rewrites: rewrites\n      }] = await Promise.all([this.pageLoader.getPageList(), (0, _routeLoader).getClientBuildManifest(), this.pageLoader.getMiddlewareList()]);\n    } catch (err) {\n      // If we fail to resolve the page list or client-build manifest, we must\n      // do a server-side transition:\n      window.location.href = as;\n      return false;\n    } // If asked to change the current URL we should reload the current page\n    // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n    // We also need to set the method = replaceState always\n    // as this should not go into the history (That's how browsers work)\n    // We should compare the new asPath to the current asPath, not the url\n\n\n    if (!this.urlIsNew(cleanedAs) && !localeChange) {\n      method = 'replaceState';\n    } // we need to resolve the as value using rewrites for dynamic SSG\n    // pages to allow building the data URL correctly\n\n\n    let resolvedAs = as; // url and as should always be prefixed with basePath by this\n    // point by either next/link or router.push/replace so strip the\n    // basePath from the pathname to match the pages dir 1-to-1\n\n    pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n\n    if (shouldResolveHref && pathname !== '/_error') {\n      options._shouldResolveHref = true;\n\n      if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n        const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(cleanedAs, this.locale)), pages, rewrites, query, p => resolveDynamicRoute(p, pages), this.locales);\n        resolvedAs = rewritesResult.asPath;\n\n        if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n          // if this directly matches a page we need to update the href to\n          // allow the correct page chunk to be loaded\n          pathname = rewritesResult.resolvedHref;\n          parsed.pathname = addBasePath(pathname);\n          url = (0, _utils).formatWithValidation(parsed);\n        }\n      } else {\n        parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n        if (parsed.pathname !== pathname) {\n          pathname = parsed.pathname;\n          parsed.pathname = addBasePath(pathname);\n          url = (0, _utils).formatWithValidation(parsed);\n        }\n      }\n    }\n\n    if (!isLocalURL(as)) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);\n      }\n\n      window.location.href = as;\n      return false;\n    }\n\n    resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);\n    const effect = await this._preflightRequest({\n      as,\n      cache: process.env.NODE_ENV === 'production',\n      pages,\n      pathname,\n      query\n    });\n\n    if (effect.type === 'rewrite') {\n      query = { ...query,\n        ...effect.parsedAs.query\n      };\n      resolvedAs = effect.asPath;\n      pathname = effect.resolvedHref;\n      parsed.pathname = effect.resolvedHref;\n      url = (0, _utils).formatWithValidation(parsed);\n    } else if (effect.type === 'redirect' && effect.newAs) {\n      return this.change(method, effect.newUrl, effect.newAs, options);\n    } else if (effect.type === 'redirect' && effect.destination) {\n      window.location.href = effect.destination;\n      return new Promise(() => {});\n    } else if (effect.type === 'refresh') {\n      window.location.href = as;\n      return new Promise(() => {});\n    }\n\n    const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n\n    if ((0, _isDynamic).isDynamicRoute(route)) {\n      const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n      const asPathname = parsedAs.pathname;\n      const routeRegex = (0, _routeRegex).getRouteRegex(route);\n      const routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n      const shouldInterpolate = route === asPathname;\n      const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n\n      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n        const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param]);\n\n        if (missingParams.length > 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n          }\n\n          throw new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);\n        }\n      } else if (shouldInterpolate) {\n        as = (0, _utils).formatWithValidation(Object.assign({}, parsedAs, {\n          pathname: interpolatedAs.result,\n          query: omitParmsFromQuery(query, interpolatedAs.params)\n        }));\n      } else {\n        // Merge params into `query`, overwriting any specified in search\n        Object.assign(query, routeMatch);\n      }\n    }\n\n    Router.events.emit('routeChangeStart', as, routeProps);\n\n    try {\n      var ref, ref1;\n      let routeInfo = await this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);\n      let {\n        error,\n        props,\n        __N_SSG,\n        __N_SSP\n      } = routeInfo; // handle redirect on client-transition\n\n      if ((__N_SSG || __N_SSP) && props) {\n        if (props.pageProps && props.pageProps.__N_REDIRECT) {\n          const destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n          // client-navigation if it is falling back to hard navigation if\n          // it's not\n\n          if (destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n            const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n            const {\n              url: newUrl,\n              as: newAs\n            } = prepareUrlAs(this, destination, destination);\n            return this.change(method, newUrl, newAs, options);\n          }\n\n          window.location.href = destination;\n          return new Promise(() => {});\n        }\n\n        this.isPreview = !!props.__N_PREVIEW; // handle SSG data 404\n\n        if (props.notFound === SSG_DATA_NOT_FOUND) {\n          let notFoundRoute;\n\n          try {\n            await this.fetchComponent('/404');\n            notFoundRoute = '/404';\n          } catch (_) {\n            notFoundRoute = '/_error';\n          }\n\n          routeInfo = await this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n            shallow: false\n          });\n        }\n      }\n\n      Router.events.emit('beforeHistoryChange', as, routeProps);\n      this.changeState(method, url, as, options);\n\n      if (options._h && pathname === '/_error' && ((ref = self.__NEXT_DATA__.props) === null || ref === void 0 ? void 0 : (ref1 = ref.pageProps) === null || ref1 === void 0 ? void 0 : ref1.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n        // ensure statusCode is still correct for static 500 page\n        // when updating query information\n        props.pageProps.statusCode = 500;\n      } // shallow routing is only allowed for same page URL changes.\n\n\n      const isValidShallowRoute = options.shallow && this.route === route;\n\n      var _scroll;\n\n      const shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;\n      const resetScroll = shouldScroll ? {\n        x: 0,\n        y: 0\n      } : null;\n      await this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch(e => {\n        if (e.cancelled) error = error || e;else throw e;\n      });\n\n      if (error) {\n        Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n        throw error;\n      }\n\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        if (this.locale) {\n          document.documentElement.lang = this.locale;\n        }\n      }\n\n      Router.events.emit('routeChangeComplete', as, routeProps);\n      return true;\n    } catch (err1) {\n      if ((0, _isError).default(err1) && err1.cancelled) {\n        return false;\n      }\n\n      throw err1;\n    }\n  }\n\n  changeState(method, url, as) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof window.history === 'undefined') {\n        console.error(`Warning: window.history is not available.`);\n        return;\n      }\n\n      if (typeof window.history[method] === 'undefined') {\n        console.error(`Warning: window.history.${method} is not available`);\n        return;\n      }\n    }\n\n    if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n      this._shallow = options.shallow;\n      window.history[method]({\n        url,\n        as,\n        options,\n        __N: true,\n        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n      }, // Most browsers currently ignores this parameter, although they may use it in the future.\n      // Passing the empty string here should be safe against future changes to the method.\n      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n      '', as);\n    }\n  }\n\n  async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n    if (err.cancelled) {\n      // bubble up cancellation errors\n      throw err;\n    }\n\n    if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n      Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons\n      //  1. Page doesn't exists\n      //  2. Page does exist in a different zone\n      //  3. Internal error while loading the page\n      // So, doing a hard reload is the proper way to deal with this.\n\n      window.location.href = as; // Changing the URL doesn't block executing the current code path.\n      // So let's throw a cancellation error stop the routing logic.\n\n      throw buildCancellationError();\n    }\n\n    try {\n      let Component;\n      let styleSheets;\n      let props;\n\n      if (typeof Component === 'undefined' || typeof styleSheets === 'undefined') {\n        ({\n          page: Component,\n          styleSheets\n        } = await this.fetchComponent('/_error'));\n      }\n\n      const routeInfo = {\n        props,\n        Component,\n        styleSheets,\n        err,\n        error: err\n      };\n\n      if (!routeInfo.props) {\n        try {\n          routeInfo.props = await this.getInitialProps(Component, {\n            err,\n            pathname,\n            query\n          });\n        } catch (gipErr) {\n          console.error('Error in error page `getInitialProps`: ', gipErr);\n          routeInfo.props = {};\n        }\n      }\n\n      return routeInfo;\n    } catch (routeInfoErr) {\n      return this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''), pathname, query, as, routeProps, true);\n    }\n  }\n\n  async getRouteInfo(route, pathname, query, as, resolvedAs, routeProps) {\n    try {\n      const existingRouteInfo = this.components[route];\n\n      if (routeProps.shallow && existingRouteInfo && this.route === route) {\n        return existingRouteInfo;\n      }\n\n      let cachedRouteInfo = undefined; // can only use non-initial route info\n      // cannot reuse route info in development since it can change after HMR\n\n      if (process.env.NODE_ENV !== 'development' && existingRouteInfo && !('initial' in existingRouteInfo)) {\n        cachedRouteInfo = existingRouteInfo;\n      }\n\n      const routeInfo = cachedRouteInfo || (await this.fetchComponent(route).then(res => ({\n        Component: res.page,\n        styleSheets: res.styleSheets,\n        __N_SSG: res.mod.__N_SSG,\n        __N_SSP: res.mod.__N_SSP,\n        __N_RSC: !!res.page.__next_rsc__\n      })));\n      const {\n        Component,\n        __N_SSG,\n        __N_SSP,\n        __N_RSC\n      } = routeInfo;\n\n      if (process.env.NODE_ENV !== 'production') {\n        const {\n          isValidElementType\n        } = require('react-is');\n\n        if (!isValidElementType(Component)) {\n          throw new Error(`The default export is not a React Component in page: \"${pathname}\"`);\n        }\n      }\n\n      let dataHref;\n\n      if (__N_SSG || __N_SSP || __N_RSC) {\n        dataHref = this.pageLoader.getDataHref({\n          href: (0, _utils).formatWithValidation({\n            pathname,\n            query\n          }),\n          asPath: resolvedAs,\n          ssg: __N_SSG,\n          rsc: __N_RSC,\n          locale: this.locale\n        });\n      }\n\n      const props = await this._getData(() => __N_SSG || __N_SSP ? fetchNextData(dataHref, this.isSsr, false, __N_SSG ? this.sdc : this.sdr, !!__N_SSG && !this.isPreview) : this.getInitialProps(Component, // we provide AppTree later so this needs to be `any`\n      {\n        pathname,\n        query,\n        asPath: as,\n        locale: this.locale,\n        locales: this.locales,\n        defaultLocale: this.defaultLocale\n      }));\n\n      if (__N_RSC) {\n        const {\n          fresh,\n          data\n        } = await this._getData(() => this._getFlightData(dataHref));\n        props.pageProps = Object.assign(props.pageProps, {\n          __flight_serialized__: data,\n          __flight_fresh__: fresh\n        });\n      }\n\n      routeInfo.props = props;\n      this.components[route] = routeInfo;\n      return routeInfo;\n    } catch (err) {\n      return this.handleRouteInfoError((0, _isError).default(err) ? err : new Error(err + ''), pathname, query, as, routeProps);\n    }\n  }\n\n  set(route, pathname, query, as, data, resetScroll) {\n    this.isFallback = false;\n    this.route = route;\n    this.pathname = pathname;\n    this.query = query;\n    this.asPath = as;\n    return this.notify(data, resetScroll);\n  }\n  /**\n  * Callback to execute before replacing router state\n  * @param cb callback to be executed\n  */\n\n\n  beforePopState(cb) {\n    this._bps = cb;\n  }\n\n  onlyAHashChange(as) {\n    if (!this.asPath) return false;\n    const [oldUrlNoHash, oldHash] = this.asPath.split('#');\n    const [newUrlNoHash, newHash] = as.split('#'); // Makes sure we scroll to the provided hash if the url/hash are the same\n\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true;\n    } // If the urls are change, there's more than a hash change\n\n\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false;\n    } // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n\n\n    return oldHash !== newHash;\n  }\n\n  scrollToHash(as) {\n    const [, hash] = as.split('#'); // Scroll to top if the hash is just `#` with no value or `#top`\n    // To mirror browsers\n\n    if (hash === '' || hash === 'top') {\n      window.scrollTo(0, 0);\n      return;\n    } // First we check if the element by id is found\n\n\n    const idEl = document.getElementById(hash);\n\n    if (idEl) {\n      idEl.scrollIntoView();\n      return;\n    } // If there's no element with the id, we check the `name` property\n    // To mirror browsers\n\n\n    const nameEl = document.getElementsByName(hash)[0];\n\n    if (nameEl) {\n      nameEl.scrollIntoView();\n    }\n  }\n\n  urlIsNew(asPath) {\n    return this.asPath !== asPath;\n  }\n  /**\n  * Prefetch page code, you may wait for the data during page rendering.\n  * This feature only works in production!\n  * @param url the href of prefetched page\n  * @param asPath the as path of the prefetched page\n  */\n\n\n  async prefetch(url) {\n    let asPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n    let {\n      pathname,\n      query\n    } = parsed;\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      if (options.locale === false) {\n        pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, this.locales).pathname;\n        parsed.pathname = pathname;\n        url = (0, _utils).formatWithValidation(parsed);\n        let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n        const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n        parsedAs.pathname = localePathResult.pathname;\n        options.locale = localePathResult.detectedLocale || this.defaultLocale;\n        asPath = (0, _utils).formatWithValidation(parsedAs);\n      }\n    }\n\n    const pages = await this.pageLoader.getPageList();\n    let resolvedAs = asPath;\n\n    if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n      let rewrites;\n      ({\n        __rewrites: rewrites\n      } = await (0, _routeLoader).getClientBuildManifest());\n      const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, p => resolveDynamicRoute(p, pages), this.locales);\n      resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n\n      if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n        // if this directly matches a page we need to update the href to\n        // allow the correct page chunk to be loaded\n        pathname = rewritesResult.resolvedHref;\n        parsed.pathname = pathname;\n        url = (0, _utils).formatWithValidation(parsed);\n      }\n    } else {\n      parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n      if (parsed.pathname !== pathname) {\n        pathname = parsed.pathname;\n        parsed.pathname = pathname;\n        url = (0, _utils).formatWithValidation(parsed);\n      }\n    } // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n\n    if (process.env.NODE_ENV !== 'production') {\n      return;\n    }\n\n    const effects = await this._preflightRequest({\n      as: addBasePath(asPath),\n      cache: true,\n      pages,\n      pathname,\n      query\n    });\n\n    if (effects.type === 'rewrite') {\n      parsed.pathname = effects.resolvedHref;\n      pathname = effects.resolvedHref;\n      query = { ...query,\n        ...effects.parsedAs.query\n      };\n      resolvedAs = effects.asPath;\n      url = (0, _utils).formatWithValidation(parsed);\n    }\n\n    const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n    await Promise.all([this.pageLoader._isSsg(route).then(isSsg => {\n      return isSsg ? fetchNextData(this.pageLoader.getDataHref({\n        href: url,\n        asPath: resolvedAs,\n        ssg: true,\n        locale: typeof options.locale !== 'undefined' ? options.locale : this.locale\n      }), false, false, this.sdc, true) : false;\n    }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n  }\n\n  async fetchComponent(route) {\n    let cancelled = false;\n\n    const cancel = this.clc = () => {\n      cancelled = true;\n    };\n\n    const handleCancelled = () => {\n      if (cancelled) {\n        const error = new Error(`Abort fetching component for route: \"${route}\"`);\n        error.cancelled = true;\n        throw error;\n      }\n\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n    };\n\n    try {\n      const componentResult = await this.pageLoader.loadPage(route);\n      handleCancelled();\n      return componentResult;\n    } catch (err) {\n      handleCancelled();\n      throw err;\n    }\n  }\n\n  _getData(fn) {\n    let cancelled = false;\n\n    const cancel = () => {\n      cancelled = true;\n    };\n\n    this.clc = cancel;\n    return fn().then(data => {\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n\n      if (cancelled) {\n        const err = new Error('Loading initial props cancelled');\n        err.cancelled = true;\n        throw err;\n      }\n\n      return data;\n    });\n  }\n\n  _getFlightData(dataHref) {\n    const {\n      href: cacheKey\n    } = new URL(dataHref, window.location.href);\n\n    if (!this.isPreview && this.sdc[cacheKey]) {\n      return Promise.resolve({\n        fresh: false,\n        data: this.sdc[cacheKey]\n      });\n    }\n\n    return fetchNextData(dataHref, true, true, this.sdc, false).then(serialized => {\n      this.sdc[cacheKey] = serialized;\n      return {\n        fresh: true,\n        data: serialized\n      };\n    });\n  }\n\n  async _preflightRequest(options) {\n    var ref;\n    const cleanedAs = delLocale(hasBasePath(options.as) ? delBasePath(options.as) : options.as, this.locale);\n    const fns = await this.pageLoader.getMiddlewareList();\n    const requiresPreflight = fns.some(_ref2 => {\n      let [middleware, isSSR] = _ref2;\n      return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware, !isSSR))(cleanedAs);\n    });\n\n    if (!requiresPreflight) {\n      return {\n        type: 'next'\n      };\n    }\n\n    const preflight = await this._getPreflightData({\n      preflightHref: options.as,\n      shouldCache: options.cache\n    });\n\n    if ((ref = preflight.rewrite) === null || ref === void 0 ? void 0 : ref.startsWith('/')) {\n      const parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, this.locales).pathname);\n      const fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n      let matchedPage;\n      let resolvedHref;\n\n      if (options.pages.includes(fsPathname)) {\n        matchedPage = true;\n        resolvedHref = fsPathname;\n      } else {\n        resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n\n        if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n          matchedPage = true;\n        }\n      }\n\n      return {\n        type: 'rewrite',\n        asPath: parsed.pathname,\n        parsedAs: parsed,\n        matchedPage,\n        resolvedHref\n      };\n    }\n\n    if (preflight.redirect) {\n      if (preflight.redirect.startsWith('/')) {\n        const cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, this.locales).pathname);\n        const {\n          url: newUrl,\n          as: newAs\n        } = prepareUrlAs(this, cleanRedirect, cleanRedirect);\n        return {\n          type: 'redirect',\n          newUrl,\n          newAs\n        };\n      }\n\n      return {\n        type: 'redirect',\n        destination: preflight.redirect\n      };\n    } // For SSR requests, they will be handled like normal pages.\n\n\n    if (preflight.refresh && !preflight.ssr) {\n      return {\n        type: 'refresh'\n      };\n    }\n\n    return {\n      type: 'next'\n    };\n  }\n\n  _getPreflightData(params) {\n    const {\n      preflightHref,\n      shouldCache = false\n    } = params;\n    const {\n      href: cacheKey\n    } = new URL(preflightHref, window.location.href);\n\n    if (process.env.NODE_ENV === 'production' && !this.isPreview && shouldCache && this.sde[cacheKey]) {\n      return Promise.resolve(this.sde[cacheKey]);\n    }\n\n    return fetch(preflightHref, {\n      method: 'HEAD',\n      credentials: 'same-origin',\n      headers: {\n        'x-middleware-preflight': '1'\n      }\n    }).then(res => {\n      if (!res.ok) {\n        throw new Error(`Failed to preflight request`);\n      }\n\n      return {\n        redirect: res.headers.get('Location'),\n        refresh: res.headers.has('x-middleware-refresh'),\n        rewrite: res.headers.get('x-middleware-rewrite'),\n        ssr: !!res.headers.get('x-middleware-ssr')\n      };\n    }).then(data => {\n      if (shouldCache) {\n        this.sde[cacheKey] = data;\n      }\n\n      return data;\n    }).catch(err => {\n      delete this.sde[cacheKey];\n      throw err;\n    });\n  }\n\n  getInitialProps(Component, ctx) {\n    const {\n      Component: App\n    } = this.components['/_app'];\n\n    const AppTree = this._wrapApp(App);\n\n    ctx.AppTree = AppTree;\n    return (0, _utils).loadGetInitialProps(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx\n    });\n  }\n\n  abortComponentLoad(as, routeProps) {\n    if (this.clc) {\n      Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n      this.clc();\n      this.clc = null;\n    }\n  }\n\n  notify(data, resetScroll) {\n    return this.sub(data, this.components['/_app'].Component, resetScroll);\n  }\n\n}\n\nRouter.events = (0, _mitt).default();\nexports.default = Router;","map":{"version":3,"sources":["../../../../shared/lib/router/router.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.default = void 0;\nvar _normalizeTrailingSlash = require(\"../../../client/normalize-trailing-slash\");\nvar _routeLoader = require(\"../../../client/route-loader\");\nvar _isError = _interopRequireDefault(require(\"../../../lib/is-error\"));\nvar _denormalizePagePath = require(\"../../../server/denormalize-page-path\");\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\nvar _mitt = _interopRequireDefault(require(\"../mitt\"));\nvar _utils = require(\"../utils\");\nvar _isDynamic = require(\"./utils/is-dynamic\");\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\nvar _querystring = require(\"./utils/querystring\");\nvar _resolveRewrites = _interopRequireDefault(require(\"./utils/resolve-rewrites\"));\nvar _routeMatcher = require(\"./utils/route-matcher\");\nvar _routeRegex = require(\"./utils/route-regex\");\nvar _getMiddlewareRegex = require(\"./utils/get-middleware-regex\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet detectDomainLocale;\nif (process.env.__NEXT_I18N_SUPPORT) {\n    detectDomainLocale = require('../i18n/detect-domain-locale').detectDomainLocale;\n}\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith('/') || !prefix) {\n        return path;\n    }\n    const pathname = pathNoQueryHash(path);\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(`${prefix}${pathname}`) + path.substr(pathname.length);\n}\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        locale = locale || (0, _normalizeLocalePath).normalizeLocalePath(path, locales).detectedLocale;\n        const detectedDomain = detectDomainLocale(domainLocales, undefined, locale);\n        if (detectedDomain) {\n            return `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${basePath || ''}${locale === detectedDomain.defaultLocale ? '' : `/${locale}`}${path}`;\n        }\n        return false;\n    } else {\n        return false;\n    }\n}\nfunction addLocale(path, locale, defaultLocale) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        const pathname = pathNoQueryHash(path);\n        const pathLower = pathname.toLowerCase();\n        const localeLower = locale && locale.toLowerCase();\n        return locale && locale !== defaultLocale && !pathLower.startsWith('/' + localeLower + '/') && pathLower !== '/' + localeLower ? addPathPrefix(path, '/' + locale) : path;\n    }\n    return path;\n}\nfunction delLocale(path, locale) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        const pathname = pathNoQueryHash(path);\n        const pathLower = pathname.toLowerCase();\n        const localeLower = locale && locale.toLowerCase();\n        return locale && (pathLower.startsWith('/' + localeLower + '/') || pathLower === '/' + localeLower) ? (pathname.length === locale.length + 1 ? '/' : '') + path.substr(locale.length + 1) : path;\n    }\n    return path;\n}\nfunction pathNoQueryHash(path) {\n    const queryIndex = path.indexOf('?');\n    const hashIndex = path.indexOf('#');\n    if (queryIndex > -1 || hashIndex > -1) {\n        path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n    }\n    return path;\n}\nfunction hasBasePath(path) {\n    path = pathNoQueryHash(path);\n    return path === basePath || path.startsWith(basePath + '/');\n}\nfunction addBasePath(path) {\n    // we only add the basepath on relative urls\n    return addPathPrefix(path, basePath);\n}\nfunction delBasePath(path) {\n    path = path.slice(basePath.length);\n    if (!path.startsWith('/')) path = `/${path}`;\n    return path;\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils).getLocationOrigin();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = '';\n    const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = // Try to match the dynamic route against the asPath\n    (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || '';\n        const { repeat , optional  } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = `[${repeat ? '...' : ''}${param}]`;\n        if (optional) {\n            replaced = `${!value ? '/' : ''}[${replaced}]`;\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// these values should be fully encoded instead of just\n        // path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)\n        ).join('/') : encodeURIComponent(value)) || '/');\n    })) {\n        interpolatedRoute = '' // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n}\nfunction omitParmsFromQuery(query, params) {\n    const filteredQuery = {\n    };\n    Object.keys(query).forEach((key)=>{\n        if (!params.includes(key)) {\n            filteredQuery[key] = query[key];\n        }\n    });\n    return filteredQuery;\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === 'string' ? href : (0, _utils).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.substr(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split('?');\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(`Invalid href passed to next/router: ${urlAsString}, repeated forward-slashes (//) or backslashes \\\\ are not valid in the href`);\n        const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        let interpolatedAs = '';\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            const { result , params  } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _utils).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omitParmsFromQuery(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = resolveHref(router, url, true);\n    const origin = (0, _utils).getLocationOrigin();\n    const hrefHadOrigin = resolvedHref.startsWith(origin);\n    const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n    const preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function() {\n    try {\n        let v = '__next';\n        // eslint-disable-next-line no-sequences\n        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n    } catch (n) {\n    }\n}();\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, opts) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin'\n    }).then((res)=>{\n        if (!res.ok) {\n            if (attempts > 1 && res.status >= 500) {\n                return fetchRetry(url, attempts - 1, opts);\n            }\n            if (res.status === 404) {\n                return res.json().then((data)=>{\n                    if (data.notFound) {\n                        return {\n                            notFound: SSG_DATA_NOT_FOUND\n                        };\n                    }\n                    throw new Error(`Failed to load static props`);\n                });\n            }\n            throw new Error(`Failed to load static props`);\n        }\n        return opts.text ? res.text() : res.json();\n    });\n}\nfunction fetchNextData(dataHref, isServerRender, text, inflightCache, persistCache) {\n    const { href: cacheKey  } = new URL(dataHref, window.location.href);\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1, {\n        text\n    }).catch((err)=>{\n        // We should only trigger a server-side transition if this was caused\n        // on a client-side transition. Otherwise, we'd get into an infinite\n        // loop.\n        if (!isServerRender) {\n            (0, _routeLoader).markAssetError(err);\n        }\n        throw err;\n    }).then((data)=>{\n        if (!persistCache || process.env.NODE_ENV !== 'production') {\n            delete inflightCache[cacheKey];\n        }\n        return data;\n    }).catch((err)=>{\n        delete inflightCache[cacheKey];\n        throw err;\n    });\n}\nclass Router {\n    constructor(pathname, query, as, { initialProps , pageLoader , App , wrapApp , Component , err , subscription , isFallback , locale , locales , defaultLocale , domainLocales , isPreview  }){\n        // Static Data Cache\n        this.sdc = {\n        };\n        // In-flight Server Data Requests, for deduping\n        this.sdr = {\n        };\n        // In-flight middleware preflight requests\n        this.sde = {\n        };\n        this._idx = 0;\n        this.onPopState = (e)=>{\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname , query  } = this;\n                this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname),\n                    query\n                }), (0, _utils).getURL());\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            let forcedScroll;\n            const { url , as , options , idx  } = state;\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    if (this._idx !== idx) {\n                        // Snapshot current scroll position:\n                        try {\n                            sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n                                x: self.pageXOffset,\n                                y: self.pageYOffset\n                            }));\n                        } catch  {\n                        }\n                        // Restore old scroll position:\n                        try {\n                            const v = sessionStorage.getItem('__next_scroll_' + idx);\n                            forcedScroll = JSON.parse(v);\n                        } catch  {\n                            forcedScroll = {\n                                x: 0,\n                                y: 0\n                            };\n                        }\n                    }\n                }\n            }\n            this._idx = idx;\n            const { pathname  } = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === this.asPath && pathname === this.pathname) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change('replaceState', url, as, Object.assign({\n            }, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale\n            }), forcedScroll);\n        };\n        // represents the current component key\n        this.route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n        // set up the component cache (by route keys)\n        this.components = {\n        };\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== '/_error') {\n            var ref;\n            this.components[this.route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP,\n                __N_RSC: !!((ref = Component) === null || ref === void 0 ? void 0 : ref.__next_rsc__)\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        this.pathname = pathname;\n        this.query = query;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname) && self.__NEXT_DATA__.autoExport;\n        this.asPath = autoExportDynamic ? pathname : as;\n        this.basePath = basePath;\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isFallback = isFallback;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n        this.isPreview = !!isPreview;\n        this.isLocaleDomain = false;\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            this.locale = locale;\n            this.locales = locales;\n            this.defaultLocale = defaultLocale;\n            this.domainLocales = domainLocales;\n            this.isLocaleDomain = !!detectDomainLocale(domainLocales, self.location.hostname);\n        }\n        if (typeof window !== 'undefined') {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (as.substr(0, 2) !== '//') {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                options._shouldResolveHref = as !== pathname;\n                this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname),\n                    query\n                }), (0, _utils).getURL(), options);\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    window.history.scrollRestoration = 'manual';\n                }\n            }\n        }\n    }\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options = {\n    }) {\n        if (process.env.__NEXT_SCROLL_RESTORATION) {\n            // TODO: remove in the future when we update history before route change\n            // is complete, as the popstate event should handle this capture.\n            if (manualScrollRestoration) {\n                try {\n                    // Snapshot scroll position right before navigating to a new page:\n                    sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n                        x: self.pageXOffset,\n                        y: self.pageYOffset\n                    }));\n                } catch  {\n                }\n            }\n        }\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('pushState', url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options = {\n    }) {\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('replaceState', url, as, options);\n    }\n    async change(method, url, as, options, forcedScroll) {\n        if (!isLocalURL(url)) {\n            window.location.href = url;\n            return false;\n        }\n        const shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as);\n        // for static pages with query params in the URL we delay\n        // marking the router ready until after the query is updated\n        if (options._h) {\n            this.isReady = true;\n        }\n        const prevLocale = this.locale;\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;\n            if (typeof options.locale === 'undefined') {\n                options.locale = this.locale;\n            }\n            const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n            const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n            if (localePathResult.detectedLocale) {\n                this.locale = localePathResult.detectedLocale;\n                parsedAs.pathname = addBasePath(parsedAs.pathname);\n                as = (0, _utils).formatWithValidation(parsedAs);\n                url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);\n            }\n            let didNavigate = false;\n            // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                var ref;\n                // if the locale isn't configured hard navigate to show 404 page\n                if (!((ref = this.locales) === null || ref === void 0 ? void 0 : ref.includes(this.locale))) {\n                    parsedAs.pathname = addLocale(parsedAs.pathname, this.locale);\n                    window.location.href = (0, _utils).formatWithValidation(parsedAs);\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                }\n            }\n            const detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale);\n            // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                // if we are navigating to a domain locale ensure we redirect to the\n                // correct domain\n                if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n                    const asNoBasePath = delBasePath(as);\n                    window.location.href = `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${addBasePath(`${this.locale === detectedDomain.defaultLocale ? '' : `/${this.locale}`}${asNoBasePath === '/' ? '' : asNoBasePath}` || '/')}`;\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                }\n            }\n            if (didNavigate) {\n                return new Promise(()=>{\n                });\n            }\n        }\n        if (!options._h) {\n            this.isSsr = false;\n        }\n        // marking route changes as a navigation start entry\n        if (_utils.ST) {\n            performance.mark('routeChange');\n        }\n        const { shallow =false  } = options;\n        const routeProps = {\n            shallow\n        };\n        if (this._inFlightRoute) {\n            this.abortComponentLoad(this._inFlightRoute, routeProps);\n        }\n        as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n        const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);\n        this._inFlightRoute = as;\n        let localeChange = prevLocale !== this.locale;\n        // If the url change is only related to a hash change\n        // We should not proceed. We should only change the state.\n        // WARNING: `_h` is an internal option for handing Next.js client-side\n        // hydration. Your app should _never_ use this property. It may change at\n        // any time without notice.\n        if (!options._h && this.onlyAHashChange(cleanedAs) && !localeChange) {\n            this.asPath = cleanedAs;\n            Router.events.emit('hashChangeStart', as, routeProps);\n            // TODO: do we need the resolved href when only a hash change?\n            this.changeState(method, url, as, options);\n            this.scrollToHash(cleanedAs);\n            this.notify(this.components[this.route], null);\n            Router.events.emit('hashChangeComplete', as, routeProps);\n            return true;\n        }\n        let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n        let { pathname , query  } = parsed;\n        // The build manifest needs to be loaded before auto-static dynamic pages\n        // get their query parameters to allow ensuring they can be parsed properly\n        // when rewritten to\n        let pages, rewrites;\n        try {\n            [pages, { __rewrites: rewrites  }] = await Promise.all([\n                this.pageLoader.getPageList(),\n                (0, _routeLoader).getClientBuildManifest(),\n                this.pageLoader.getMiddlewareList(), \n            ]);\n        } catch (err) {\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            window.location.href = as;\n            return false;\n        }\n        // If asked to change the current URL we should reload the current page\n        // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n        // We also need to set the method = replaceState always\n        // as this should not go into the history (That's how browsers work)\n        // We should compare the new asPath to the current asPath, not the url\n        if (!this.urlIsNew(cleanedAs) && !localeChange) {\n            method = 'replaceState';\n        }\n        // we need to resolve the as value using rewrites for dynamic SSG\n        // pages to allow building the data URL correctly\n        let resolvedAs = as;\n        // url and as should always be prefixed with basePath by this\n        // point by either next/link or router.push/replace so strip the\n        // basePath from the pathname to match the pages dir 1-to-1\n        pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n        if (shouldResolveHref && pathname !== '/_error') {\n            options._shouldResolveHref = true;\n            if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n                const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(cleanedAs, this.locale)), pages, rewrites, query, (p)=>resolveDynamicRoute(p, pages)\n                , this.locales);\n                resolvedAs = rewritesResult.asPath;\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                    // if this directly matches a page we need to update the href to\n                    // allow the correct page chunk to be loaded\n                    pathname = rewritesResult.resolvedHref;\n                    parsed.pathname = addBasePath(pathname);\n                    url = (0, _utils).formatWithValidation(parsed);\n                }\n            } else {\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                    pathname = parsed.pathname;\n                    parsed.pathname = addBasePath(pathname);\n                    url = (0, _utils).formatWithValidation(parsed);\n                }\n            }\n        }\n        if (!isLocalURL(as)) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);\n            }\n            window.location.href = as;\n            return false;\n        }\n        resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);\n        const effect = await this._preflightRequest({\n            as,\n            cache: process.env.NODE_ENV === 'production',\n            pages,\n            pathname,\n            query\n        });\n        if (effect.type === 'rewrite') {\n            query = {\n                ...query,\n                ...effect.parsedAs.query\n            };\n            resolvedAs = effect.asPath;\n            pathname = effect.resolvedHref;\n            parsed.pathname = effect.resolvedHref;\n            url = (0, _utils).formatWithValidation(parsed);\n        } else if (effect.type === 'redirect' && effect.newAs) {\n            return this.change(method, effect.newUrl, effect.newAs, options);\n        } else if (effect.type === 'redirect' && effect.destination) {\n            window.location.href = effect.destination;\n            return new Promise(()=>{\n            });\n        } else if (effect.type === 'refresh') {\n            window.location.href = as;\n            return new Promise(()=>{\n            });\n        }\n        const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n        if ((0, _isDynamic).isDynamicRoute(route)) {\n            const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n            const asPathname = parsedAs.pathname;\n            const routeRegex = (0, _routeRegex).getRouteRegex(route);\n            const routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n            const shouldInterpolate = route === asPathname;\n            const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {\n            };\n            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param]\n                );\n                if (missingParams.length > 0) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n                    }\n                    throw new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);\n                }\n            } else if (shouldInterpolate) {\n                as = (0, _utils).formatWithValidation(Object.assign({\n                }, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: omitParmsFromQuery(query, interpolatedAs.params)\n                }));\n            } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n            }\n        }\n        Router.events.emit('routeChangeStart', as, routeProps);\n        try {\n            var ref, ref1;\n            let routeInfo = await this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps);\n            let { error , props , __N_SSG , __N_SSP  } = routeInfo;\n            // handle redirect on client-transition\n            if ((__N_SSG || __N_SSP) && props) {\n                if (props.pageProps && props.pageProps.__N_REDIRECT) {\n                    const destination = props.pageProps.__N_REDIRECT;\n                    // check if destination is internal (resolves to a page) and attempt\n                    // client-navigation if it is falling back to hard navigation if\n                    // it's not\n                    if (destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                        const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                        const { url: newUrl , as: newAs  } = prepareUrlAs(this, destination, destination);\n                        return this.change(method, newUrl, newAs, options);\n                    }\n                    window.location.href = destination;\n                    return new Promise(()=>{\n                    });\n                }\n                this.isPreview = !!props.__N_PREVIEW;\n                // handle SSG data 404\n                if (props.notFound === SSG_DATA_NOT_FOUND) {\n                    let notFoundRoute;\n                    try {\n                        await this.fetchComponent('/404');\n                        notFoundRoute = '/404';\n                    } catch (_) {\n                        notFoundRoute = '/_error';\n                    }\n                    routeInfo = await this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n                        shallow: false\n                    });\n                }\n            }\n            Router.events.emit('beforeHistoryChange', as, routeProps);\n            this.changeState(method, url, as, options);\n            if (options._h && pathname === '/_error' && ((ref = self.__NEXT_DATA__.props) === null || ref === void 0 ? void 0 : (ref1 = ref.pageProps) === null || ref1 === void 0 ? void 0 : ref1.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                props.pageProps.statusCode = 500;\n            }\n            // shallow routing is only allowed for same page URL changes.\n            const isValidShallowRoute = options.shallow && this.route === route;\n            var _scroll;\n            const shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;\n            const resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n            } : null;\n            await this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch((e)=>{\n                if (e.cancelled) error = error || e;\n                else throw e;\n            });\n            if (error) {\n                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                throw error;\n            }\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                if (this.locale) {\n                    document.documentElement.lang = this.locale;\n                }\n            }\n            Router.events.emit('routeChangeComplete', as, routeProps);\n            return true;\n        } catch (err1) {\n            if ((0, _isError).default(err1) && err1.cancelled) {\n                return false;\n            }\n            throw err1;\n        }\n    }\n    changeState(method, url, as, options = {\n    }) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof window.history === 'undefined') {\n                console.error(`Warning: window.history is not available.`);\n                return;\n            }\n            if (typeof window.history[method] === 'undefined') {\n                console.error(`Warning: window.history.${method} is not available`);\n                return;\n            }\n        }\n        if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n            }, // Most browsers currently ignores this parameter, although they may use it in the future.\n            // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n            '', as);\n        }\n    }\n    async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        if (err.cancelled) {\n            // bubble up cancellation errors\n            throw err;\n        }\n        if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n            Router.events.emit('routeChangeError', err, as, routeProps);\n            // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n            window.location.href = as;\n            // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n            throw buildCancellationError();\n        }\n        try {\n            let Component;\n            let styleSheets;\n            let props;\n            if (typeof Component === 'undefined' || typeof styleSheets === 'undefined') {\n                ({ page: Component , styleSheets  } = await this.fetchComponent('/_error'));\n            }\n            const routeInfo = {\n                props,\n                Component,\n                styleSheets,\n                err,\n                error: err\n            };\n            if (!routeInfo.props) {\n                try {\n                    routeInfo.props = await this.getInitialProps(Component, {\n                        err,\n                        pathname,\n                        query\n                    });\n                } catch (gipErr) {\n                    console.error('Error in error page `getInitialProps`: ', gipErr);\n                    routeInfo.props = {\n                    };\n                }\n            }\n            return routeInfo;\n        } catch (routeInfoErr) {\n            return this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''), pathname, query, as, routeProps, true);\n        }\n    }\n    async getRouteInfo(route, pathname, query, as, resolvedAs, routeProps) {\n        try {\n            const existingRouteInfo = this.components[route];\n            if (routeProps.shallow && existingRouteInfo && this.route === route) {\n                return existingRouteInfo;\n            }\n            let cachedRouteInfo = undefined;\n            // can only use non-initial route info\n            // cannot reuse route info in development since it can change after HMR\n            if (process.env.NODE_ENV !== 'development' && existingRouteInfo && !('initial' in existingRouteInfo)) {\n                cachedRouteInfo = existingRouteInfo;\n            }\n            const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res)=>({\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP,\n                    __N_RSC: !!res.page.__next_rsc__\n                })\n            );\n            const { Component , __N_SSG , __N_SSP , __N_RSC  } = routeInfo;\n            if (process.env.NODE_ENV !== 'production') {\n                const { isValidElementType  } = require('react-is');\n                if (!isValidElementType(Component)) {\n                    throw new Error(`The default export is not a React Component in page: \"${pathname}\"`);\n                }\n            }\n            let dataHref;\n            if (__N_SSG || __N_SSP || __N_RSC) {\n                dataHref = this.pageLoader.getDataHref({\n                    href: (0, _utils).formatWithValidation({\n                        pathname,\n                        query\n                    }),\n                    asPath: resolvedAs,\n                    ssg: __N_SSG,\n                    rsc: __N_RSC,\n                    locale: this.locale\n                });\n            }\n            const props = await this._getData(()=>__N_SSG || __N_SSP ? fetchNextData(dataHref, this.isSsr, false, __N_SSG ? this.sdc : this.sdr, !!__N_SSG && !this.isPreview) : this.getInitialProps(Component, // we provide AppTree later so this needs to be `any`\n                {\n                    pathname,\n                    query,\n                    asPath: as,\n                    locale: this.locale,\n                    locales: this.locales,\n                    defaultLocale: this.defaultLocale\n                })\n            );\n            if (__N_RSC) {\n                const { fresh , data  } = await this._getData(()=>this._getFlightData(dataHref)\n                );\n                props.pageProps = Object.assign(props.pageProps, {\n                    __flight_serialized__: data,\n                    __flight_fresh__: fresh\n                });\n            }\n            routeInfo.props = props;\n            this.components[route] = routeInfo;\n            return routeInfo;\n        } catch (err) {\n            return this.handleRouteInfoError((0, _isError).default(err) ? err : new Error(err + ''), pathname, query, as, routeProps);\n        }\n    }\n    set(route, pathname, query, as, data, resetScroll) {\n        this.isFallback = false;\n        this.route = route;\n        this.pathname = pathname;\n        this.query = query;\n        this.asPath = as;\n        return this.notify(data, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split('#');\n        const [newUrlNoHash, newHash] = as.split('#');\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash] = as.split('#');\n        // Scroll to top if the hash is just `#` with no value or `#top`\n        // To mirror browsers\n        if (hash === '' || hash === 'top') {\n            window.scrollTo(0, 0);\n            return;\n        }\n        // First we check if the element by id is found\n        const idEl = document.getElementById(hash);\n        if (idEl) {\n            idEl.scrollIntoView();\n            return;\n        }\n        // If there's no element with the id, we check the `name` property\n        // To mirror browsers\n        const nameEl = document.getElementsByName(hash)[0];\n        if (nameEl) {\n            nameEl.scrollIntoView();\n        }\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ async prefetch(url, asPath = url, options = {\n    }) {\n        let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n        let { pathname , query  } = parsed;\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            if (options.locale === false) {\n                pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, this.locales).pathname;\n                parsed.pathname = pathname;\n                url = (0, _utils).formatWithValidation(parsed);\n                let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n                const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n                parsedAs.pathname = localePathResult.pathname;\n                options.locale = localePathResult.detectedLocale || this.defaultLocale;\n                asPath = (0, _utils).formatWithValidation(parsedAs);\n            }\n        }\n        const pages = await this.pageLoader.getPageList();\n        let resolvedAs = asPath;\n        if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n            let rewrites;\n            ({ __rewrites: rewrites  } = await (0, _routeLoader).getClientBuildManifest());\n            const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, (p)=>resolveDynamicRoute(p, pages)\n            , this.locales);\n            resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n            if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                // if this directly matches a page we need to update the href to\n                // allow the correct page chunk to be loaded\n                pathname = rewritesResult.resolvedHref;\n                parsed.pathname = pathname;\n                url = (0, _utils).formatWithValidation(parsed);\n            }\n        } else {\n            parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n            if (parsed.pathname !== pathname) {\n                pathname = parsed.pathname;\n                parsed.pathname = pathname;\n                url = (0, _utils).formatWithValidation(parsed);\n            }\n        }\n        // Prefetch is not supported in development mode because it would trigger on-demand-entries\n        if (process.env.NODE_ENV !== 'production') {\n            return;\n        }\n        const effects = await this._preflightRequest({\n            as: addBasePath(asPath),\n            cache: true,\n            pages,\n            pathname,\n            query\n        });\n        if (effects.type === 'rewrite') {\n            parsed.pathname = effects.resolvedHref;\n            pathname = effects.resolvedHref;\n            query = {\n                ...query,\n                ...effects.parsedAs.query\n            };\n            resolvedAs = effects.asPath;\n            url = (0, _utils).formatWithValidation(parsed);\n        }\n        const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n        await Promise.all([\n            this.pageLoader._isSsg(route).then((isSsg)=>{\n                return isSsg ? fetchNextData(this.pageLoader.getDataHref({\n                    href: url,\n                    asPath: resolvedAs,\n                    ssg: true,\n                    locale: typeof options.locale !== 'undefined' ? options.locale : this.locale\n                }), false, false, this.sdc, true) : false;\n            }),\n            this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), \n        ]);\n    }\n    async fetchComponent(route) {\n        let cancelled = false;\n        const cancel = this.clc = ()=>{\n            cancelled = true;\n        };\n        const handleCancelled = ()=>{\n            if (cancelled) {\n                const error = new Error(`Abort fetching component for route: \"${route}\"`);\n                error.cancelled = true;\n                throw error;\n            }\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n        };\n        try {\n            const componentResult = await this.pageLoader.loadPage(route);\n            handleCancelled();\n            return componentResult;\n        } catch (err) {\n            handleCancelled();\n            throw err;\n        }\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error('Loading initial props cancelled');\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        const { href: cacheKey  } = new URL(dataHref, window.location.href);\n        if (!this.isPreview && this.sdc[cacheKey]) {\n            return Promise.resolve({\n                fresh: false,\n                data: this.sdc[cacheKey]\n            });\n        }\n        return fetchNextData(dataHref, true, true, this.sdc, false).then((serialized)=>{\n            this.sdc[cacheKey] = serialized;\n            return {\n                fresh: true,\n                data: serialized\n            };\n        });\n    }\n    async _preflightRequest(options) {\n        var ref;\n        const cleanedAs = delLocale(hasBasePath(options.as) ? delBasePath(options.as) : options.as, this.locale);\n        const fns = await this.pageLoader.getMiddlewareList();\n        const requiresPreflight = fns.some(([middleware, isSSR])=>{\n            return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware, !isSSR))(cleanedAs);\n        });\n        if (!requiresPreflight) {\n            return {\n                type: 'next'\n            };\n        }\n        const preflight = await this._getPreflightData({\n            preflightHref: options.as,\n            shouldCache: options.cache\n        });\n        if ((ref = preflight.rewrite) === null || ref === void 0 ? void 0 : ref.startsWith('/')) {\n            const parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, this.locales).pathname);\n            const fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n            let matchedPage;\n            let resolvedHref;\n            if (options.pages.includes(fsPathname)) {\n                matchedPage = true;\n                resolvedHref = fsPathname;\n            } else {\n                resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n                if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n                    matchedPage = true;\n                }\n            }\n            return {\n                type: 'rewrite',\n                asPath: parsed.pathname,\n                parsedAs: parsed,\n                matchedPage,\n                resolvedHref\n            };\n        }\n        if (preflight.redirect) {\n            if (preflight.redirect.startsWith('/')) {\n                const cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, this.locales).pathname);\n                const { url: newUrl , as: newAs  } = prepareUrlAs(this, cleanRedirect, cleanRedirect);\n                return {\n                    type: 'redirect',\n                    newUrl,\n                    newAs\n                };\n            }\n            return {\n                type: 'redirect',\n                destination: preflight.redirect\n            };\n        }\n        // For SSR requests, they will be handled like normal pages.\n        if (preflight.refresh && !preflight.ssr) {\n            return {\n                type: 'refresh'\n            };\n        }\n        return {\n            type: 'next'\n        };\n    }\n    _getPreflightData(params) {\n        const { preflightHref , shouldCache =false  } = params;\n        const { href: cacheKey  } = new URL(preflightHref, window.location.href);\n        if (process.env.NODE_ENV === 'production' && !this.isPreview && shouldCache && this.sde[cacheKey]) {\n            return Promise.resolve(this.sde[cacheKey]);\n        }\n        return fetch(preflightHref, {\n            method: 'HEAD',\n            credentials: 'same-origin',\n            headers: {\n                'x-middleware-preflight': '1'\n            }\n        }).then((res)=>{\n            if (!res.ok) {\n                throw new Error(`Failed to preflight request`);\n            }\n            return {\n                redirect: res.headers.get('Location'),\n                refresh: res.headers.has('x-middleware-refresh'),\n                rewrite: res.headers.get('x-middleware-rewrite'),\n                ssr: !!res.headers.get('x-middleware-ssr')\n            };\n        }).then((data)=>{\n            if (shouldCache) {\n                this.sde[cacheKey] = data;\n            }\n            return data;\n        }).catch((err)=>{\n            delete this.sde[cacheKey];\n            throw err;\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App  } = this.components['/_app'];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils).loadGetInitialProps(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    abortComponentLoad(as, routeProps) {\n        if (this.clc) {\n            Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n            this.clc();\n            this.clc = null;\n        }\n    }\n    notify(data, resetScroll) {\n        return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n}\nRouter.events = (0, _mitt).default();\nexports.default = Router;\n\n"]},"metadata":{},"sourceType":"script"}